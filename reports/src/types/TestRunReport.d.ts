/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * monitoring.uss_qualifier.reports.report.TestRunReport, as defined in monitoring/uss_qualifier/reports/report.py
 */
export interface ReportsReportTestRunReport {
  /**
   * Path to content that replaces the $ref
   */
  // $ref?: string;
  /**
   * Signature of the test run including codebase version and all file signatures except excluded environmental files.
   *
   * This field can be used to identify that a particular expected test baseline (codebase, all non-environmental inputs)
   * was run.  The value of this field is computed from codebase_version and all elements of the configuration that are
   * not explicitly excluded as environmental configuration.
   */
  baseline_signature: string;
  /**
   * Version of codebase used to run uss_qualifier
   */
  codebase_version: string;
  /**
   * Full commit hash of codebase used to run uss_qualifier
   */
  commit_hash: string;
  configuration: ConfigurationsConfigurationTestConfiguration;
  /**
   * Signature of the environmental inputs of the configuration not included in the baseline signature.
   */
  environment_signature: string;
  report: ReportsReportTestSuiteActionReport;
  [k: string]: unknown;
}
/**
 * Configuration used to run uss_qualifier
 */
export interface ConfigurationsConfigurationTestConfiguration {
  /**
   * Path to content that replaces the $ref
   */
  // $ref?: string;
  action: SuitesDefinitionsTestSuiteActionDeclaration;
  /**
   * List of portions of the configuration that should not be considered when computing the test baseline signature (e.g., environmental definitions).
   */
  non_baseline_inputs?: string[] | null;
  resources: ResourcesDefinitionsResourceCollection;
  [k: string]: unknown;
}
/**
 * The action this test configuration wants to run (usually a test suite)
 */
export interface SuitesDefinitionsTestSuiteActionDeclaration {
  /**
   * Path to content that replaces the $ref
   */
  // $ref?: string;
  /**
   * If this field is populated, declaration of a generator that will produce 0 or more test suite actions
   */
  action_generator?: null | ActionGeneratorsDefinitionsActionGeneratorDefinition;
  /**
   * What to do if this action fails
   */
  on_failure?: "Continue" | "Abort";
  /**
   * If this field is populated, declaration of the test scenario to run
   */
  test_scenario?: null | ScenariosDefinitionsTestScenarioDeclaration;
  /**
   * If this field is populated, declaration of the test suite to run
   */
  test_suite?: null | SuitesDefinitionsTestSuiteDeclaration;
  [k: string]: unknown;
}
/**
 * monitoring.uss_qualifier.action_generators.definitions.ActionGeneratorDefinition, as defined in monitoring/uss_qualifier/action_generators/definitions.py
 */
export interface ActionGeneratorsDefinitionsActionGeneratorDefinition {
  /**
   * Path to content that replaces the $ref
   */
  // $ref?: string;
  /**
   * Type of action generator
   */
  generator_type: string;
  /**
   * Mapping of the ID a resource will be known by in the child action -> the ID a resource is known by in the parent test suite.
   *
   * The child action resource ID <key> is supplied by the parent test suite resource ID <value>.
   *
   * Resources not included in this field will not be available to the child action.
   *
   * If the parent resource ID is suffixed with ? then the resource will not be required (and will not be populated for the child action when not present in the parent)
   */
  resources: {
    /**
     * Path to content that replaces the $ref
     */
    // $ref?: string;
    [k: string]: string;
  };
  /**
   * Specification of action generator; format is the ActionGeneratorSpecificationType that corresponds to the `generator_type`
   */
  specification?: {
    [k: string]: unknown;
  };
  [k: string]: unknown;
}
/**
 * monitoring.uss_qualifier.scenarios.definitions.TestScenarioDeclaration, as defined in monitoring/uss_qualifier/scenarios/definitions.py
 */
export interface ScenariosDefinitionsTestScenarioDeclaration {
  /**
   * Path to content that replaces the $ref
   */
  // $ref?: string;
  /**
   * Mapping of the ID a resource in the test scenario -> the ID a resource is known by in the parent test suite.
   *
   * The additional argument to concrete test scenario constructor <key> is supplied by the parent suite resource <value>.
   */
  resources?: {
    /**
     * Path to content that replaces the $ref
     */
    // $ref?: string;
    [k: string]: string;
  } | null;
  /**
   * Type of test scenario.
   */
  scenario_type: string;
  [k: string]: unknown;
}
/**
 * monitoring.uss_qualifier.suites.definitions.TestSuiteDeclaration, as defined in monitoring/uss_qualifier/suites/definitions.py
 */
export interface SuitesDefinitionsTestSuiteDeclaration {
  /**
   * Path to content that replaces the $ref
   */
  // $ref?: string;
  /**
   * Definition of test suite internal to the configuration -- specified instead of `suite_type`.
   */
  suite_definition?: null | SuitesDefinitionsTestSuiteDefinition;
  /**
   * Mapping of the ID a resource will be known by in the child test suite -> the ID a resource is known by in the parent test suite.
   *
   * The child suite resource <key> is supplied by the parent suite resource <value>.
   */
  resources: {
    /**
     * Path to content that replaces the $ref
     */
    // $ref?: string;
    [k: string]: string;
  };
  /**
   * Type/location of test suite.  Usually expressed as the file name of the suite definition (without extension) qualified relative to the `uss_qualifier` folder
   */
  suite_type?: string | null;
  [k: string]: unknown;
}
/**
 * Schema for the definition of a test suite, analogous to the Python TestScenario subclass for scenarios
 *
 * monitoring.uss_qualifier.suites.definitions.TestSuiteDefinition, as defined in monitoring/uss_qualifier/suites/definitions.py
 */
export interface SuitesDefinitionsTestSuiteDefinition {
  /**
   * Path to content that replaces the $ref
   */
  // $ref?: string;
  /**
   * Name of the test suite
   */
  name: string;
  /**
   * The scenario executed after all the actions that evaluates the test suite report. Must be a ReportEvaluationScenario.
   */
  report_evaluation_scenario?: null | ScenariosDefinitionsTestScenarioDeclaration;
  /**
   * Definitions of capabilities verified by this test suite for individual participants.
   */
  participant_verifiable_capabilities?:
    | ReportsCapabilityDefinitionsParticipantCapabilityDefinition[]
    | null;
  /**
   * Enumeration of the resources used by this test suite
   */
  resources: {
    /**
     * Path to content that replaces the $ref
     */
    // $ref?: string;
    [k: string]: string;
  };
  /**
   * The actions to take when running the test suite.  Components will be executed in order.
   */
  actions: SuitesDefinitionsTestSuiteActionDeclaration1[];
  [k: string]: unknown;
}
/**
 * monitoring.uss_qualifier.reports.capability_definitions.ParticipantCapabilityDefinition, as defined in monitoring/uss_qualifier/reports/capability_definitions.py
 */
export interface ReportsCapabilityDefinitionsParticipantCapabilityDefinition {
  /**
   * Path to content that replaces the $ref
   */
  // $ref?: string;
  /**
   * Human-readable description of the capability.
   */
  description: string;
  verification_condition: ReportsCapabilityDefinitionsCapabilityVerificationCondition;
  /**
   * Human-readable name of the capability.
   */
  name: string;
  /**
   * Identifier of this capability, unique at the level in which this capability is defined.
   */
  id: string;
  [k: string]: unknown;
}
/**
 * Condition required in order to verify the capability.
 */
export interface ReportsCapabilityDefinitionsCapabilityVerificationCondition {
  /**
   * Path to content that replaces the $ref
   */
  // $ref?: string;
  no_failed_checks?: null | ReportsCapabilityDefinitionsNoFailedChecksCondition;
  any_conditions?: null | ReportsCapabilityDefinitionsAnyCondition;
  requirements_checked?: null | ReportsCapabilityDefinitionsRequirementsCheckedCondition;
  all_conditions?: null | ReportsCapabilityDefinitionsAllConditions;
  capability_verified?: null | ReportsCapabilityDefinitionsCapabilityVerifiedCondition;
  [k: string]: unknown;
}
/**
 * Condition will only be satisfied if there are no applicable failed checks.
 *
 * For a capability to be verified for a participant, only checks including the participant's ID will be considered.
 *
 * monitoring.uss_qualifier.reports.capability_definitions.NoFailedChecksCondition, as defined in monitoring/uss_qualifier/reports/capability_definitions.py
 */
export interface ReportsCapabilityDefinitionsNoFailedChecksCondition {
  /**
   * Path to content that replaces the $ref
   */
  // $ref?: string;
  [k: string]: unknown;
}
/**
 * Condition will be satisfied when any of the specified conditions are satisfied.
 *
 * Note that an empty list of conditions will result in an unsuccessful evaluation.
 *
 * monitoring.uss_qualifier.reports.capability_definitions.AnyCondition, as defined in monitoring/uss_qualifier/reports/capability_definitions.py
 */
export interface ReportsCapabilityDefinitionsAnyCondition {
  /**
   * Path to content that replaces the $ref
   */
  // $ref?: string;
  conditions: ReportsCapabilityDefinitionsCapabilityVerificationCondition1[];
  [k: string]: unknown;
}
/**
 * Specification of a single condition used to determine whether a capability should be verified.
 *
 * Exactly one field must be specified.
 *
 * monitoring.uss_qualifier.reports.capability_definitions.CapabilityVerificationCondition, as defined in monitoring/uss_qualifier/reports/capability_definitions.py
 */
export interface ReportsCapabilityDefinitionsCapabilityVerificationCondition1 {
  /**
   * Path to content that replaces the $ref
   */
  // $ref?: string;
  no_failed_checks?: null | ReportsCapabilityDefinitionsNoFailedChecksCondition;
  any_conditions?: null | ReportsCapabilityDefinitionsAnyCondition;
  requirements_checked?: null | ReportsCapabilityDefinitionsRequirementsCheckedCondition;
  all_conditions?: null | ReportsCapabilityDefinitionsAllConditions;
  capability_verified?: null | ReportsCapabilityDefinitionsCapabilityVerifiedCondition;
  [k: string]: unknown;
}
/**
 * Condition will only be satisfied if at least one successful check exists for all specified requirements.
 *
 * Note that an empty collection of requirements will result in an unsuccessful evaluation.
 *
 * monitoring.uss_qualifier.reports.capability_definitions.RequirementsCheckedCondition, as defined in monitoring/uss_qualifier/reports/capability_definitions.py
 */
export interface ReportsCapabilityDefinitionsRequirementsCheckedCondition {
  /**
   * Path to content that replaces the $ref
   */
  // $ref?: string;
  checked: RequirementsDefinitionsRequirementCollection;
  [k: string]: unknown;
}
/**
 * Each requirement contained within this collection must be covered by at least one successful check.
 */
export interface RequirementsDefinitionsRequirementCollection {
  /**
   * Path to content that replaces the $ref
   */
  // $ref?: string;
  /**
   * This collection includes all of the requirements in all of these requirement collections.
   */
  requirement_collections?:
    | RequirementsDefinitionsRequirementCollection1[]
    | null;
  /**
   * This collection includes all of these requirements.
   */
  requirements?: string[] | null;
  /**
   * This collection includes all requirements in all of these requirement sets.
   */
  requirement_sets?: string[] | null;
  /**
   * This collection does not include any of these requirements, despite all previous fields.
   */
  exclude?: null | RequirementsDefinitionsRequirementCollection1;
  [k: string]: unknown;
}
/**
 * monitoring.uss_qualifier.requirements.definitions.RequirementCollection, as defined in monitoring/uss_qualifier/requirements/definitions.py
 */
export interface RequirementsDefinitionsRequirementCollection1 {
  /**
   * Path to content that replaces the $ref
   */
  // $ref?: string;
  /**
   * This collection includes all of the requirements in all of these requirement collections.
   */
  requirement_collections?:
    | RequirementsDefinitionsRequirementCollection1[]
    | null;
  /**
   * This collection includes all of these requirements.
   */
  requirements?: string[] | null;
  /**
   * This collection includes all requirements in all of these requirement sets.
   */
  requirement_sets?: string[] | null;
  /**
   * This collection does not include any of these requirements, despite all previous fields.
   */
  exclude?: null | RequirementsDefinitionsRequirementCollection1;
  [k: string]: unknown;
}
/**
 * Condition will only be satisfied when all specified conditions are satisfied.
 *
 * Note that an empty list of conditions will result in a successful evaluation.
 *
 * monitoring.uss_qualifier.reports.capability_definitions.AllConditions, as defined in monitoring/uss_qualifier/reports/capability_definitions.py
 */
export interface ReportsCapabilityDefinitionsAllConditions {
  /**
   * Path to content that replaces the $ref
   */
  // $ref?: string;
  conditions: ReportsCapabilityDefinitionsCapabilityVerificationCondition1[];
  [k: string]: unknown;
}
/**
 * Condition will be satisfied when the specified capability is verified.
 *
 * Note that a capability which do not declare any requirement will result in an unsuccessful evaluation.
 *
 * monitoring.uss_qualifier.reports.capability_definitions.CapabilityVerifiedCondition, as defined in monitoring/uss_qualifier/reports/capability_definitions.py
 */
export interface ReportsCapabilityDefinitionsCapabilityVerifiedCondition {
  /**
   * Path to content that replaces the $ref
   */
  // $ref?: string;
  /**
   * Location of report to inspect for the verification of the specified capability, relative to the report in which
   * the capability is defined.  Implicit default value is "$" (look for verified capability in the report in which the
   * dependant capability is defined).
   *
   * If this location resolves to multiple TestSuiteReports, then the capability must be verified in all resolved reports
   * in order for this condition to be satisfied.  When this location resolves to artifacts that are not
   * TestSuiteReports, those artifacts will be ignored.
   *
   * Note that capabilities are verified in the order they are defined.  So, if capability B defined in a particular
   * location depends on whether capability A in that same location is granted, capability A must be defined before
   * capability B is defined.  Also note that capability verifications are computed as test components are completed.
   * Since a parent test component (e.g., test suite) is not complete until all of its child components are complete, a
   * descendant test component's capability condition cannot depend on whether an ancestor's (e.g., parent's) capability
   * is verified.
   */
  capability_location?: string | null;
  /**
   * List of identifier of capability that must be verified for this condition to be satisfied.
   */
  capability_ids: string[];
  [k: string]: unknown;
}
/**
 * Defines a step in the sequence of things to do for a test suite.
 *
 * Exactly one of `test_scenario`, `test_suite`, or `action_generator` must be specified.
 *
 * monitoring.uss_qualifier.suites.definitions.TestSuiteActionDeclaration, as defined in monitoring/uss_qualifier/suites/definitions.py
 */
export interface SuitesDefinitionsTestSuiteActionDeclaration1 {
  /**
   * Path to content that replaces the $ref
   */
  // $ref?: string;
  /**
   * If this field is populated, declaration of a generator that will produce 0 or more test suite actions
   */
  action_generator?: null | ActionGeneratorsDefinitionsActionGeneratorDefinition;
  /**
   * What to do if this action fails
   */
  on_failure?: "Continue" | "Abort";
  /**
   * If this field is populated, declaration of the test scenario to run
   */
  test_scenario?: null | ScenariosDefinitionsTestScenarioDeclaration;
  /**
   * If this field is populated, declaration of the test suite to run
   */
  test_suite?: null | SuitesDefinitionsTestSuiteDeclaration;
  [k: string]: unknown;
}
/**
 * Declarations for resources used by the test suite
 */
export interface ResourcesDefinitionsResourceCollection {
  /**
   * Path to content that replaces the $ref
   */
  // $ref?: string;
  /**
   * Mapping of globally (within resource collection) unique name identifying a resource to the declaration of that resource
   */
  resource_declarations: {
    /**
     * Path to content that replaces the $ref
     */
    // $ref?: string;
    [
      k: string
    ]: ResourcesDefinitionsResourceDeclaration;
  };
  [k: string]: unknown;
}
/**
 * monitoring.uss_qualifier.resources.definitions.ResourceDeclaration, as defined in monitoring/uss_qualifier/resources/definitions.py
 */
export interface ResourcesDefinitionsResourceDeclaration {
  /**
   * Path to content that replaces the $ref
   */
  // $ref?: string;
  /**
   * Mapping of dependency parameter (additional argument to concrete resource constructor) to `name` of resource to use
   */
  dependencies?: {
    /**
     * Path to content that replaces the $ref
     */
    // $ref?: string;
    [k: string]: string;
  };
  /**
   * Type of resource, expressed as a Python class name qualified relative to this `resources` module
   */
  resource_type: string;
  /**
   * Specification of resource; format is the SpecificationType that corresponds to the `resource_type`
   */
  specification?: {
    [k: string]: unknown;
  };
  [k: string]: unknown;
}
/**
 * Report produced by configured test action
 */
export interface ReportsReportTestSuiteActionReport {
  /**
   * Path to content that replaces the $ref
   */
  // $ref?: string;
  /**
   * If this action was a test scenario, this field will hold its report
   */
  test_scenario?: null | ReportsReportTestScenarioReport;
  /**
   * If this action was an action generator, this field will hold its report
   */
  action_generator?: null | ReportsReportActionGeneratorReport;
  /**
   * If this action was a test suite, this field will hold its report
   */
  test_suite?: null | ReportsReportTestSuiteReport;
  [k: string]: unknown;
}
/**
 * monitoring.uss_qualifier.reports.report.TestScenarioReport, as defined in monitoring/uss_qualifier/reports/report.py
 */
export interface ReportsReportTestScenarioReport {
  /**
   * Path to content that replaces the $ref
   */
  // $ref?: string;
  /**
   * True iff test scenario completed normally with no failed checks
   */
  successful?: boolean;
  /**
   * Time at which the test scenario started
   */
  start_time: string;
  /**
   * Reports for each of the test cases in this test scenario
   */
  cases: ReportsReportTestCaseReport[];
  /**
   * URL at which this test scenario is described
   */
  documentation_url: string;
  /**
   * If there was an error while executing this test scenario, this field describes the error
   */
  execution_error?: null | ReportsReportErrorReport;
  /**
   * Time at which the test scenario completed or encountered an error
   */
  end_time?: string | null;
  /**
   * If this test scenario performed cleanup, this report captures the relevant information.
   */
  cleanup?: null | ReportsReportTestStepReport;
  /**
   * Additional information about this scenario that may be useful
   */
  notes?: {
    /**
     * Path to content that replaces the $ref
     */
    // $ref?: string;
    [k: string]: ReportsReportNote;
  } | null;
  /**
   * Type of this test scenario
   */
  scenario_type: string;
  /**
   * Name of this test scenario
   */
  name: string;
  [k: string]: unknown;
}
/**
 * monitoring.uss_qualifier.reports.report.TestCaseReport, as defined in monitoring/uss_qualifier/reports/report.py
 */
export interface ReportsReportTestCaseReport {
  /**
   * Path to content that replaces the $ref
   */
  // $ref?: string;
  /**
   * Name of this test case
   */
  name: string;
  /**
   * URL at which this test case is described
   */
  documentation_url: string;
  /**
   * Time at which the test case completed or encountered an error
   */
  end_time?: string | null;
  /**
   * Time at which the test case started
   */
  start_time: string;
  /**
   * Reports for each of the test steps in this test case
   */
  steps: ReportsReportTestStepReport[];
  [k: string]: unknown;
}
/**
 * monitoring.uss_qualifier.reports.report.TestStepReport, as defined in monitoring/uss_qualifier/reports/report.py
 */
export interface ReportsReportTestStepReport {
  /**
   * Path to content that replaces the $ref
   */
  // $ref?: string;
  /**
   * The checks which failed in this test step
   */
  failed_checks: ReportsReportFailedCheck[];
  /**
   * Name of this test step
   */
  name: string;
  /**
   * URL at which this test step is described
   */
  documentation_url: string;
  /**
   * Time at which the test step completed or encountered an error
   */
  end_time?: string | null;
  /**
   * Description of HTTP requests relevant to this issue
   */
  queries?: HttpsGithubComInterussMonitoringBlobMainSchemasMonitoringMonitorlibFetchQueryJson[] | null;
  /**
   * Time at which the test step started
   */
  start_time: string;
  /**
   * The checks which successfully passed in this test step
   */
  passed_checks: ReportsReportPassedCheck[];
  [k: string]: unknown;
}
/**
 * monitoring.uss_qualifier.reports.report.FailedCheck, as defined in monitoring/uss_qualifier/reports/report.py
 */
export interface ReportsReportFailedCheck {
  /**
   * Path to content that replaces the $ref
   */
  // $ref?: string;
  /**
   * Name of the check that failed
   */
  name: string;
  /**
   * URL at which the check which failed is described
   */
  documentation_url: string;
  /**
   * Human-readable summary of the issue
   */
  summary: string;
  /**
   * Human-readable description of the issue
   */
  details: string;
  /**
   * List of the `report` timestamp field for queries relevant to this failed check
   */
  query_report_timestamps?: string[] | null;
  /**
   * How severe the issue is
   */
  severity: "Critical" | "High" | "Medium" | "Low";
  /**
   * Participants that may not meet the relevant requirements due to this failed check
   */
  participants: string[];
  /**
   * Requirements that are not met due to this failed check
   */
  requirements: string[];
  /**
   * Time the issue was discovered
   */
  timestamp: string;
  /**
   * Additional data, structured according to the checks' needs, that may be relevant for understanding this failed check
   */
  additional_data?: {
    [k: string]: unknown;
  } | null;
  [k: string]: unknown;
}
/**
 * monitoring.monitorlib.fetch.Query, as defined in monitoring/monitorlib/fetch/__init__.py
 */
export interface HttpsGithubComInterussMonitoringBlobMainSchemasMonitoringMonitorlibFetchQueryJson {
  /**
   * Path to content that replaces the $ref
   */
  // $ref?: string;
  /**
   * If specified, the recognized type of this query.
   */
  query_type?:
    | (
        | "astm.f3411.v22a.sp.flights"
        | "astm.f3411.v19.sp.flights"
        | "astm.f3411.v22a.sp.flight_details"
        | "astm.f3411.v19.sp.flight_details"
        | "astm.f3548.v21.dss.queryOperationalIntentReferences"
        | "astm.f3548.v21.dss.getOperationalIntentReference"
        | "astm.f3548.v21.dss.createOperationalIntentReference"
        | "astm.f3548.v21.dss.updateOperationalIntentReference"
        | "astm.f3548.v21.dss.deleteOperationalIntentReference"
        | "astm.f3548.v21.dss.queryConstraintReferences"
        | "astm.f3548.v21.dss.getConstraintReference"
        | "astm.f3548.v21.dss.createConstraintReference"
        | "astm.f3548.v21.dss.updateConstraintReference"
        | "astm.f3548.v21.dss.deleteConstraintReference"
        | "astm.f3548.v21.dss.querySubscriptions"
        | "astm.f3548.v21.dss.getSubscription"
        | "astm.f3548.v21.dss.createSubscription"
        | "astm.f3548.v21.dss.updateSubscription"
        | "astm.f3548.v21.dss.deleteSubscription"
        | "astm.f3548.v21.dss.makeDssReport"
        | "astm.f3548.v21.uss.setUssAvailability"
        | "astm.f3548.v21.uss.getUssAvailability"
        | "astm.f3548.v21.uss.getOperationalIntentDetails"
        | "astm.f3548.v21.uss.getOperationalIntentTelemetry"
        | "astm.f3548.v21.uss.notifyOperationalIntentDetailsChanged"
        | "astm.f3548.v21.uss.getConstraintDetails"
        | "astm.f3548.v21.uss.notifyConstraintDetailsChanged"
        | "astm.f3548.v21.uss.makeUssReport"
      )
    | null;
  request: HttpsGithubComInterussMonitoringBlobMainSchemasMonitoringMonitorlibFetchRequestDescriptionJson;
  response: HttpsGithubComInterussMonitoringBlobMainSchemasMonitoringMonitorlibFetchResponseDescriptionJson;
  /**
   * If specified, identifier of the USS/participant hosting the server involved in this query.
   */
  server_id?: string | null;
  [k: string]: unknown;
}
/**
 * monitoring.monitorlib.fetch.RequestDescription, as defined in monitoring/monitorlib/fetch/__init__.py
 */
export interface HttpsGithubComInterussMonitoringBlobMainSchemasMonitoringMonitorlibFetchRequestDescriptionJson {
  /**
   * Path to content that replaces the $ref
   */
  // $ref?: string;
  initiated_at?: string | null;
  received_at?: string | null;
  headers?: {
    [k: string]: unknown;
  } | null;
  json?: {
    [k: string]: unknown;
  } | null;
  method: string;
  url: string;
  body?: string | null;
  [k: string]: unknown;
}
/**
 * monitoring.monitorlib.fetch.ResponseDescription, as defined in monitoring/monitorlib/fetch/__init__.py
 */
export interface HttpsGithubComInterussMonitoringBlobMainSchemasMonitoringMonitorlibFetchResponseDescriptionJson {
  /**
   * Path to content that replaces the $ref
   */
  // $ref?: string;
  code?: number | null;
  failure?: string | null;
  headers?: {
    [k: string]: unknown;
  } | null;
  json?: {
    [k: string]: unknown;
  } | null;
  elapsed_s: number;
  body?: string | null;
  reported: string;
  [k: string]: unknown;
}
/**
 * monitoring.uss_qualifier.reports.report.PassedCheck, as defined in monitoring/uss_qualifier/reports/report.py
 */
export interface ReportsReportPassedCheck {
  /**
   * Path to content that replaces the $ref
   */
  // $ref?: string;
  /**
   * Participants that may not have met the relevant requirements if this check had failed
   */
  participants: string[];
  /**
   * Name of the check that passed
   */
  name: string;
  /**
   * Requirements that would not have been met if this check had failed
   */
  requirements: string[];
  [k: string]: unknown;
}
/**
 * monitoring.uss_qualifier.reports.report.ErrorReport, as defined in monitoring/uss_qualifier/reports/report.py
 */
export interface ReportsReportErrorReport {
  /**
   * Path to content that replaces the $ref
   */
  // $ref?: string;
  /**
   * Error message
   */
  message: string;
  /**
   * Full stack trace of error
   */
  stacktrace: string;
  /**
   * Type of error
   */
  type: string;
  /**
   * Time at which the error was logged
   */
  timestamp: string;
  [k: string]: unknown;
}
/**
 * monitoring.uss_qualifier.reports.report.Note, as defined in monitoring/uss_qualifier/reports/report.py
 */
export interface ReportsReportNote {
  /**
   * Path to content that replaces the $ref
   */
  // $ref?: string;
  message: string;
  timestamp: string;
  [k: string]: unknown;
}
/**
 * monitoring.uss_qualifier.reports.report.ActionGeneratorReport, as defined in monitoring/uss_qualifier/reports/report.py
 */
export interface ReportsReportActionGeneratorReport {
  /**
   * Path to content that replaces the $ref
   */
  // $ref?: string;
  /**
   * Type of action generator
   */
  generator_type: string;
  /**
   * Reports from the actions generated by the action generator
   */
  actions: ReportsReportTestSuiteActionReport1[];
  [k: string]: unknown;
}
/**
 * monitoring.uss_qualifier.reports.report.TestSuiteActionReport, as defined in monitoring/uss_qualifier/reports/report.py
 */
export interface ReportsReportTestSuiteActionReport1 {
  /**
   * Path to content that replaces the $ref
   */
  // $ref?: string;
  /**
   * If this action was a test scenario, this field will hold its report
   */
  test_scenario?: null | ReportsReportTestScenarioReport;
  /**
   * If this action was an action generator, this field will hold its report
   */
  action_generator?: null | ReportsReportActionGeneratorReport;
  /**
   * If this action was a test suite, this field will hold its report
   */
  test_suite?: null | ReportsReportTestSuiteReport;
  [k: string]: unknown;
}
/**
 * monitoring.uss_qualifier.reports.report.TestSuiteReport, as defined in monitoring/uss_qualifier/reports/report.py
 */
export interface ReportsReportTestSuiteReport {
  /**
   * Path to content that replaces the $ref
   */
  // $ref?: string;
  /**
   * True iff test suite completed normally with no failed checks
   */
  successful?: boolean;
  /**
   * Time at which the test suite started
   */
  start_time: string;
  /**
   * URL at which this test suite is described
   */
  documentation_url: string;
  /**
   * List of capabilities defined in this test suite, evaluated for each participant.
   */
  capability_evaluations: ReportsReportParticipantCapabilityEvaluationReport[];
  /**
   * Time at which the test suite completed
   */
  end_time?: string | null;
  /**
   * Reports from test scenarios and test suites comprising the test suite for this report
   */
  actions: ReportsReportTestSuiteActionReport1[];
  /**
   * Type/location of this test suite
   */
  suite_type: string;
  /**
   * Name of this test suite
   */
  name: string;
  [k: string]: unknown;
}
/**
 * monitoring.uss_qualifier.reports.report.ParticipantCapabilityEvaluationReport, as defined in monitoring/uss_qualifier/reports/report.py
 */
export interface ReportsReportParticipantCapabilityEvaluationReport {
  /**
   * Path to content that replaces the $ref
   */
  // $ref?: string;
  condition_evaluation: ReportsReportParticipantCapabilityConditionEvaluationReport;
  /**
   * Whether the capability was successfully verified.
   */
  verified: boolean;
  /**
   * ID of participant for which capability is being evaluated.
   */
  participant_id: string;
  /**
   * ID of capability being evaluated.
   */
  capability_id: string;
  [k: string]: unknown;
}
/**
 * Report produced by evaluating the condition for verifying this capability.
 */
export interface ReportsReportParticipantCapabilityConditionEvaluationReport {
  /**
   * Path to content that replaces the $ref
   */
  // $ref?: string;
  /**
   * When specified, the condition evaluated was CapabilityVerifiedCondition.
   */
  capability_verified?: null | ReportsReportCapabilityVerifiedConditionEvaluationReport;
  /**
   * When specified, the condition evaluated was NoFailedChecksCondition.
   */
  no_failed_checks?: null | ReportsReportNoFailedChecksConditionEvaluationReport;
  /**
   * Whether the condition was satisfied for the relevant participant.
   */
  condition_satisfied: boolean;
  /**
   * When specified, the condition evaluated was AnyCondition.
   */
  any_conditions?: null | ReportsReportAnyConditionEvaluationReport;
  /**
   * When specified, the condition evaluated was RequirementsCheckedCondition.
   */
  requirements_checked?: null | ReportsReportRequirementsCheckedConditionEvaluationReport;
  /**
   * When specified, the condition evaluated was AllConditions.
   */
  all_conditions?: null | ReportsReportAllConditionsEvaluationReport;
  [k: string]: unknown;
}
/**
 * Result of an evaluation of a CapabilityVerifiedCondition dependent on whether other capabilities were verified.
 *
 * monitoring.uss_qualifier.reports.report.CapabilityVerifiedConditionEvaluationReport, as defined in monitoring/uss_qualifier/reports/report.py
 */
export interface ReportsReportCapabilityVerifiedConditionEvaluationReport {
  /**
   * Path to content that replaces the $ref
   */
  // $ref?: string;
  /**
   * All capability evaluations checked for this condition.
   */
  checked_capabilities: ReportsReportCheckedCapability[];
  /**
   * Report elements matching the condition's `capability_location`, but not of the type TestSuiteReport.
   */
  spurious_matches: ReportsReportSpuriousReportMatch[];
  /**
   * Capabilities specified for this condition but not found in the report.
   */
  missing_capabilities: string[];
  [k: string]: unknown;
}
/**
 * Existing/previous participant-verifiable capability upon which a CapabilityVerifiedCondition depends.
 *
 * monitoring.uss_qualifier.reports.report.CheckedCapability, as defined in monitoring/uss_qualifier/reports/report.py
 */
export interface ReportsReportCheckedCapability {
  /**
   * Path to content that replaces the $ref
   */
  // $ref?: string;
  /**
   * Whether this capability was successfully verified
   */
  capability_verified: boolean;
  /**
   * The location of the ParticipantCapabilityConditionEvaluationReport for the capability, relative to the TestSuiteReport in which this checked requirement is located.
   */
  capability_location: string;
  /**
   * Location of the ParticipantCapabilityEvaluationReport for the existing/previous capability, relative to the TestSuiteReport in which the CapabilityVerifiedConditionEvaluationReport containing this CheckedCapability is located.
   */
  report_location: string;
  /**
   * ID of the existing/previous participant-verifiable capability.
   */
  capability_id: string;
  [k: string]: unknown;
}
/**
 * Participant-verifiable capability evaluations are only present in TestSuiteReports.  If a CapabilityVerifiedCondition points to a report element that is not a TestSuiteReport, an instance of this class will be generated.
 *
 * monitoring.uss_qualifier.reports.report.SpuriousReportMatch, as defined in monitoring/uss_qualifier/reports/report.py
 */
export interface ReportsReportSpuriousReportMatch {
  /**
   * Path to content that replaces the $ref
   */
  // $ref?: string;
  /**
   * Data type of the report element (not TestSuiteReport).
   */
  type: string;
  /**
   * Location of the non-TestSuiteReport report element matching the CapabilityVerifiedCondition's `capability_location`, relative to the TestSuiteReport in which this condition is located.
   */
  location: string;
  [k: string]: unknown;
}
/**
 * Result of an evaluation of NoFailedChecksCondition dependent on whether any checks failed within the scope of the test suite in which this condition is located.
 *
 * monitoring.uss_qualifier.reports.report.NoFailedChecksConditionEvaluationReport, as defined in monitoring/uss_qualifier/reports/report.py
 */
export interface ReportsReportNoFailedChecksConditionEvaluationReport {
  /**
   * Path to content that replaces the $ref
   */
  // $ref?: string;
  /**
   * The location of each FailedCheck, relative to the TestSuiteReport in which this report is located.
   */
  failed_checks: string[];
  [k: string]: unknown;
}
/**
 * Result of an evaluation of AnyCondition determined by whether any of the subconditions are satisfied.
 *
 * monitoring.uss_qualifier.reports.report.AnyConditionEvaluationReport, as defined in monitoring/uss_qualifier/reports/report.py
 */
export interface ReportsReportAnyConditionEvaluationReport {
  /**
   * Path to content that replaces the $ref
   */
  // $ref?: string;
  /**
   * Which of the specified options were satisfied (if any were satisfied, then this condition should be satisfied).
   */
  satisfied_options: ReportsReportParticipantCapabilityConditionEvaluationReport1[];
  /**
   * Which of the specified options were not satisfied (these are informational only and do not affect the evaluation).
   */
  unsatisfied_options: ReportsReportParticipantCapabilityConditionEvaluationReport1[];
  [k: string]: unknown;
}
/**
 * Result of an evaluation of a condition related to whether a participant capability should be verified.
 *
 * Exactly one field other than `condition_satisfied` must be specified.
 *
 * monitoring.uss_qualifier.reports.report.ParticipantCapabilityConditionEvaluationReport, as defined in monitoring/uss_qualifier/reports/report.py
 */
export interface ReportsReportParticipantCapabilityConditionEvaluationReport1 {
  /**
   * Path to content that replaces the $ref
   */
  // $ref?: string;
  /**
   * When specified, the condition evaluated was CapabilityVerifiedCondition.
   */
  capability_verified?: null | ReportsReportCapabilityVerifiedConditionEvaluationReport;
  /**
   * When specified, the condition evaluated was NoFailedChecksCondition.
   */
  no_failed_checks?: null | ReportsReportNoFailedChecksConditionEvaluationReport;
  /**
   * Whether the condition was satisfied for the relevant participant.
   */
  condition_satisfied: boolean;
  /**
   * When specified, the condition evaluated was AnyCondition.
   */
  any_conditions?: null | ReportsReportAnyConditionEvaluationReport;
  /**
   * When specified, the condition evaluated was RequirementsCheckedCondition.
   */
  requirements_checked?: null | ReportsReportRequirementsCheckedConditionEvaluationReport;
  /**
   * When specified, the condition evaluated was AllConditions.
   */
  all_conditions?: null | ReportsReportAllConditionsEvaluationReport;
  [k: string]: unknown;
}
/**
 * Result of an evaluation of RequirementsCheckedCondition dependent on whether a set of requirements were successfully checked.
 *
 * monitoring.uss_qualifier.reports.report.RequirementsCheckedConditionEvaluationReport, as defined in monitoring/uss_qualifier/reports/report.py
 */
export interface ReportsReportRequirementsCheckedConditionEvaluationReport {
  /**
   * Path to content that replaces the $ref
   */
  // $ref?: string;
  /**
   * Requirements with only PassedChecks.
   */
  passed_requirements: ReportsReportCheckedRequirement[];
  /**
   * Requirements with FailedChecks.
   */
  failed_requirements: ReportsReportCheckedRequirement[];
  /**
   * Requirements that didn't have any PassedChecks or FailedChecks within the scope of the test suite in which this condition is located.
   */
  untested_requirements: string[];
  [k: string]: unknown;
}
/**
 * A single requirement being checked for participant-verifiable capability verification.
 *
 * monitoring.uss_qualifier.reports.report.CheckedRequirement, as defined in monitoring/uss_qualifier/reports/report.py
 */
export interface ReportsReportCheckedRequirement {
  /**
   * Path to content that replaces the $ref
   */
  // $ref?: string;
  /**
   * The location of each PassedCheck involving the requirement of interest, relative to the TestSuiteReport in which the RequirementsCheckedConditionEvaluationReport containing this checked requirement is located.
   */
  passed_checks: string[];
  /**
   * The location of each PassedCheck involving the requirement of interest, relative to the TestSuiteReport in which the RequirementsCheckedConditionEvaluationReport containing this checked requirement is located.
   */
  failed_checks: string[];
  /**
   * The requirement being checked.
   */
  requirement_id: string;
  [k: string]: unknown;
}
/**
 * Result of an evaluation of AllConditions determined by whether all the subconditions are satisfied.
 *
 * monitoring.uss_qualifier.reports.report.AllConditionsEvaluationReport, as defined in monitoring/uss_qualifier/reports/report.py
 */
export interface ReportsReportAllConditionsEvaluationReport {
  /**
   * Path to content that replaces the $ref
   */
  // $ref?: string;
  /**
   * All of the conditions that were satisfied (there must be at least one).
   */
  satisfied_conditions: ReportsReportParticipantCapabilityConditionEvaluationReport1[];
  /**
   * All of the conditions that were unsatisfied (if any, then this condition will not be satisfied).
   */
  unsatisfied_conditions: ReportsReportParticipantCapabilityConditionEvaluationReport1[];
  [k: string]: unknown;
}
